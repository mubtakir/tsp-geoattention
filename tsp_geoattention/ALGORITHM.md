# 🧠 شرح الخوارزمية الهجينة TSP-GeoAttention

## 📋 المحتويات
1. [المقدمة](#المقدمة)
2. [المفاهيم الأساسية](#المفاهيم-الأساسية)
3. [خطوات الخوارزمية](#خطوات-الخوارزمية)
4. [التعقيد الزمني](#التعقيد-الزمني)
5. [الأمثلة](#الأمثلة)

---

## المقدمة

مسألة البائع المتجول (TSP) هي مشكلة NP-Hard كلاسيكية. الحل الأمثل يتطلب فحص O(n!) من التباديل.

الحل الهجين يجمع بين ثلاثة مفاهيم:
- **الهندسة المكانية**: تقسيم المشكلة إلى أجزاء أصغر
- **الفيزياء**: مبدأ الفعل الأدنى
- **الذكاء الاصطناعي**: آلية الانتباه

---

## المفاهيم الأساسية

### 1. الهندسة المكانية (Geo-Zoning)

```
المدينة الأصلية (n مدينة)
        ↓
    [Bounding Box]
        ↓
    [شبكة m×m]
        ↓
    [خلايا محلية]
```

**الفائدة**: تقليل فضاء البحث من O(n!) إلى مشاكل أصغر

### 2. مبدأ الفعل الأدنى (Principle of Least Action)

من الفيزياء الكلاسيكية:
```
S = ∫ L dt = ∫ (T - V) dt
```

**التطبيق على TSP**:
```
Action(مسار) = ∑ المسافات بين المدن
نبحث عن المسار ذو Action الأدنى
```

### 3. آلية الانتباه (Attention Mechanism)

من نماذج الترانسفورمر:
```
Attention(Q, K, V) = softmax(Q·K^T / √d_k) · V
```

**التطبيق على TSP**:
```
Attention(مدينة_حالية, مدن_أخرى) = softmax(-المسافات / √d_k)
```

---

## خطوات الخوارزمية

### الخطوة 1: تقسيم المساحة

```python
# حساب المربع المحيط
min_x, min_y = cities.min()
max_x, max_y = cities.max()

# إضافة هامش
margin = 0.1 * max(width, height)

# تقسيم إلى شبكة
cell_width = (max_x - min_x) / grid_size
cell_height = (max_y - min_y) / grid_size
```

**التعقيد**: O(n)

### الخطوة 2: تعيين المدن إلى الخلايا

```python
for each city (x, y):
    col = (x - min_x) / cell_width
    row = (y - min_y) / cell_height
    cell_to_cities[cell].append(city)
```

**التعقيد**: O(n)

### الخطوة 3: المسح الحلزوني

```
ترتيب الخلايا من المحيط إلى المركز:

[1][2][3]
[8][9][4]
[7][6][5]
```

**الفائدة**: تقليل القفزات العشوائية بين الخلايا

**التعقيد**: O(m²) حيث m = grid_size

### الخطوة 4: الانتباه بين الخلايا

```python
for each cell in spiral_order:
    # حساب المسافة إلى الخلايا المتبقية
    scores = [-distance(current_center, other_center) 
              for other in remaining_cells]
    
    # تطبيق softmax
    probs = softmax(scores)
    
    # اختيار الخلية التالية
    next_cell = argmax(probs)
```

**التعقيد**: O(m² log m)

### الخطوة 5: حل محلي (Intra-Cell TSP)

```python
for each cell:
    # Nearest Neighbor + Attention
    current = first_city_in_cell
    unvisited = remaining_cities_in_cell
    
    while unvisited:
        # حساب الانتباه
        scores = [-distance(current, city) for city in unvisited]
        probs = softmax(scores)
        
        # اختيار المدينة التالية
        next_city = argmax(probs)
        tour.append(next_city)
        unvisited.remove(next_city)
```

**التعقيد**: O(k²) حيث k = متوسط المدن في الخلية

### الخطوة 6: التحسين العالمي (2-opt)

```python
for iteration in range(max_iterations):
    # اختيار عشوائي لنقطتين
    i, j = random_choice(tour_length, 2)
    
    # عكس الجزء بينهما
    new_tour = tour[:i] + tour[i:j][::-1] + tour[j:]
    
    # قبول إذا كان أفضل
    if distance(new_tour) < distance(tour):
        tour = new_tour
```

**التعقيد**: O(iterations × n²)

---

## التعقيد الزمني

| المرحلة | التعقيد |
|--------|--------|
| تقسيم المساحة | O(n) |
| تعيين المدن | O(n) |
| المسح الحلزوني | O(m²) |
| الانتباه بين الخلايا | O(m² log m) |
| الحل المحلي | O(n × k) حيث k ≈ n/m² |
| التحسين العالمي | O(iterations × n²) |
| **الإجمالي** | **O(n² log n)** تقريبًا |

**مقارنة**:
- الحل الأمثل: O(n!)
- الحل الهجين: O(n² log n)
- تحسن: من 10! = 3.6M إلى 10² log 10 ≈ 664

---

## الأمثلة

### مثال 1: 4 مدن في مربع

```
المدن: (0,0), (1,0), (1,1), (0,1)
Grid Size: 2

الخلايا:
[0,0] → مدينة 0
[0,1] → مدينة 1
[1,1] → مدينة 2
[1,0] → مدينة 3

المسح الحلزوني: [0,0] → [0,1] → [1,1] → [1,0]

المسار النهائي: 0 → 1 → 2 → 3 → 0
المسافة: 4.0
```

### مثال 2: 8 مدن عشوائية

```
Grid Size: 3 (شبكة 3×3)

الخلايا المشغولة: 6 خلايا
الخلايا الفارغة: 3 خلايا

المسح الحلزوني يتجاهل الخلايا الفارغة
الانتباه يختار أفضل ترتيب للخلايا المشغولة
```

---

## المزايا والعيوب

### ✅ المزايا
- سرعة عملية: O(n² log n) بدلاً من O(n!)
- قابلية التوسع: يعمل مع آلاف المدن
- مرونة: يدعم أنواع مسافات مختلفة
- ذكاء مكاني: يستفيد من البنية الجغرافية

### ⚠️ العيوب
- لا يضمن الأمثلية (NP-Hard)
- يعتمد على اختيار grid_size
- قد لا يكون أمثل للتوزيعات غير المنتظمة

---

## التحسينات المستقبلية

1. **Quadtree**: تقسيم تكيفي بدل الشبكة الثابتة
2. **تعلم عميق**: تدريب نموذج لتحسين أوزان الانتباه
3. **Genetic Algorithm**: دمج مع خوارزميات تطورية
4. **Parallel Processing**: معالجة متوازية للخلايا

---

**الباحث**: باسل يحيى عبدالله

